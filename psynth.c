/* psynth - A simple pulse wave softsynth */

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <stdarg.h>
#include <sys/time.h>
#include <unistd.h>

#include <jack/jack.h>
#include <jack/midiport.h>
#include "ecb.h"

#define VOICES 32

static void die_if(bool cond, const char *fmt, ...)
{
	if (cond) {
		va_list ap;
		va_start(ap, fmt);
		vfprintf(stderr, fmt, ap);
		fprintf(stderr, "\n");
		va_end(ap);
		exit(EXIT_FAILURE);
	}
}

/*
 * notes.h is auto-generated by notes.py and contains the number of frames
 * that have to pass before a voice playing a given note has to toggle its
 * state.
 */
#define NOTE(length) (length),
static const unsigned int notes[128] = {
#include "notes.h"
};

typedef jack_default_audio_sample_t sample_t;

struct voice {
	/* The note played by this voice.
	   0..128: valid notes, 255: no note */
	unsigned int note:8;
	unsigned int phase:1;
	unsigned int pos:23;
} ecb_attribute((__packed__));

struct synth_state {
	unsigned playing; /* nr. of voices playing */
	sample_t base_amp;
	bool xor; /* xor mode */
	struct voice voices[VOICES];
};

static struct synth_state state;
static jack_client_t *client;
static jack_port_t *in_port, *out_port;

static void synth_init(void)
{
	int i;

	state.playing = 0;
	state.base_amp = .5;
	state.xor = false;
	for (i = 0; i < VOICES; i++) {
		state.voices[i].note = 255;
		state.voices[i].phase = 1;
		state.voices[i].pos = 0;
	}
}

static void dump_midi_event(jack_midi_event_t *event)
{
	int i;

	printf("midi event");
	if (event->size > 100)
		printf(" of size %u", event->size);
	else
		for (i = 0; i < event->size; i++)
			printf(" %02x", event->buffer[i]);
	printf("\n");
}

static void process_midi(jack_nframes_t nframes)
{
	void *buffer = jack_port_get_buffer(in_port, nframes);
	jack_midi_event_t event;
	int i, j, tmp;

	for (i = 0; jack_midi_event_get(&event, buffer, i) == 0; i++) {
		if (event.size == 0)
			continue;

		if ((event.buffer[0] & 0xf0) == 0x90) { /* note on */
			int free_voice = -1;
			unsigned int note = event.buffer[1];

			if (!state.playing) {
				state.voices[0].note = note;
				state.voices[0].pos = 0;
				state.playing = 1;
				continue;
			}

			/* Try finding a free voice slot, and check if the note
			 * is already playing. */
			for (j = 0; j < VOICES; j++) {
				if (state.voices[j].note == 255) {
					if (free_voice == -1)
						free_voice = j;
					continue;
				}

				if (state.voices[j].note == note)
					break;
			}

			if (free_voice != -1) {
				state.voices[free_voice].note = note;
				state.voices[free_voice].pos = 0;
				state.playing++;
			}
		} else if ((event.buffer[0] & 0xf0) == 0x80) { /* note off */
			unsigned note = event.buffer[1];

			for (j = 0; j < VOICES; j++) {
				if (state.voices[j].note == note) {
					state.voices[j].note = 255;
					state.playing--;
					break;
				}
			}
		} else if ((event.buffer[0] & 0xf0) == 0xc0) { /* program change */
			switch (event.buffer[1]) {
			case 0:
				state.xor = false;
				break;
			case 1:
				state.xor = true;
				break;
			default: /* nop */
				break;
			}
		}
		/* all other controllers are ignored yet */
	}
}

static void process_audio(jack_nframes_t nframes)
{
	int amp = 0;
	sample_t *buffer = jack_port_get_buffer(out_port, nframes);
	int i, j;

	if (!state.playing) {
		for (i = 0; i < nframes; i++)
			buffer[i] = 0.0;
		return;
	}

	/* fill the buffer */
	for (i = 0; i < nframes; i++) {
		/* determine resulting amplitude */
		amp = 0;
		for (j = 0; j < VOICES; j++) {
			struct voice *v = &state.voices[j];
			if (v->note != 255) {
				v->pos++;
				if (v->pos >= notes[v->note]) {
					v->phase ^= 1;
					v->pos -= notes[v->note];
				}
				if (state.xor)
					amp += v->phase;
				else
					amp += v->phase? 1 : -1;
			}
		}
		if (state.xor)
			buffer[i] = (amp&1)? state.base_amp : -state.base_amp;
		else
			buffer[i] = state.base_amp * amp;
	}
}

static int process_cb(jack_nframes_t nframes, ecb_unused void *data)
{
	process_midi(nframes);
	process_audio(nframes);

	return 0;
}

static void jack_init(void)
{
	client = jack_client_open("psynth", JackNullOption, NULL);
	die_if(client == NULL, "FATAL: Can't setup Jack client");

	in_port = jack_port_register(client, "midi_in",
			JACK_DEFAULT_MIDI_TYPE, JackPortIsInput, 0);
	out_port = jack_port_register(client, "audio_out",
			JACK_DEFAULT_AUDIO_TYPE, JackPortIsOutput, 0);
	die_if(!in_port || !out_port, "FATAL: Can't setup Jack ports");

	jack_set_process_callback(client, process_cb, NULL);

	jack_activate(client);
}

int main(void)
{
	synth_init();
	jack_init();

	pause();

	return EXIT_SUCCESS;
}
